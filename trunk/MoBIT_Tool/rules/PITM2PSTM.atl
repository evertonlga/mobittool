module PITM2PSTM; -- Module Template
create OUT : JavaAbstractSyntax from IN : uml2, KobrA : uml2, BIT : uml2;

helper def : nameOfOperation (e : uml2!EventOccurrence): 
	String = e.receiveMessage.signature.name; 

helper def: set:
	Sequence(uml2!Class) = Sequence{}; 
	
helper def: servers: --Sevidores
	Set(uml2!Class) = Set{}; 

helper def: server: 
	uml2!Class = ' ';
	
helper def: testable: 
	uml2!Class = ' ';
	
helper def: clients: -- Clientes 
	Set(uml2!Class) = Set{};

helper def: client: 
	uml2!Class = ' ';
	
helper def: testing: 
	uml2!Class = ' ';
	
helper def: verdict: --Enumeration Verdict
	JavaAbstractSyntax!EnumConstantDeclaration = '';

helper def: arbiterJ: -- Classe Arbiter
	JavaAbstractSyntax!TypeDeclaration =   ' ';

helper def: arbiter: -- Classe Java Arbiter
	uml2!Class =   ' ';

helper def: unit:
	JavaAbstractSyntax!CompilationUnit = ' '; 

helper def: strcPack:
	JavaAbstractSyntax!StructuralPackage = '';

helper def: number:
	Integer = 0;

helper def: numberOfSituations:
	Integer = 0;

helper def: elseSituation:
	JavaAbstractSyntax!Block = '';

-------------- Cria as divisoes em Packages------------------
rule createStructuralPackage{
	from model:uml2!Model
	to
	 pack: JavaAbstractSyntax!StructuralPackage(
	 	structuralPackages <- Set{packConfig},
		name <- 'Root'
	 ),
	 
	 packConfig: JavaAbstractSyntax!StructuralPackage(
	 	compilations <- Set{},
		name <- 'Aux' 
	 )
	 do{
 	    thisModule.strcPack <- pack;
	 	self.createVerdict(packConfig);
	 	self.createArbiter(packConfig);
	 	self.CreateBIT();
	 }
}

----------------- Cria o Enum Verdict -------------------------
rule createVerdict(pack: JavaAbstractSyntax!StructuralPackage){
	using{
		enumLit: Sequence(uml2!EnumerationLiteral) = uml2!Enumeration->allInstances()->select(e | e.name= 'Verdict')->first().ownedLiteral;
	}
	to 
	 comp: JavaAbstractSyntax!CompilationUnit(
	 	types<- Set{verd},
		package <- Config_Pack
	 ),
	 
	 Config_Pack: JavaAbstractSyntax!PackageDeclaration(
		name <- Config_Name ,
		javadoc <- javaDoc
	 ),
	
     Config_Name: JavaAbstractSyntax!SimpleName(
		identifier<- 'Config',
		fullyQualifiedName <- 'Config'
	 ), 
	
	 javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- Config_Pack 
	 ),
	
	verd: JavaAbstractSyntax!EnumDeclaration(
		name <- nameEnum,
		javadoc <- javaD,
		enumConstants <- Set{}
	),
	
	nameEnum:JavaAbstractSyntax!SimpleName(
		identifier<- 'Verdict',
		fullyQualifiedName <- 'Verdict' 
	),
	
	 javaD: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{javadoc},
		alternateRoot <- verd
	 ),
	 
	 javadoc: JavaAbstractSyntax!TagElement(
	 	tagName <- 'EnumVerdict',
	 	nested <- true,
		fragments <- Sequence{javadocText}
	 ),
	 
	 javadocText: JavaAbstractSyntax!TextElement(
	 	text <- 'This code is automatically generated by the MoBIT Tool  
		@author Everton Leandro'
	 )
 		
	do{
		--uml2!Enumeration->allInstances().toString().println();-->select(e | e.name= 'Verdict')->first().ownedLiteral.toString().println();
		for (lit in enumLit){
			self.createLiteral(verd, lit.name); 
		}
		thisModule.verdict <- verd;
		pack.compilations <- pack.compilations->including(comp);
		
	}
}

rule createLiteral(enum: JavaAbstractSyntax!EnumDeclaration, name : String){
	to 
	lit: JavaAbstractSyntax!EnumConstantDeclaration(
	    name <- nameLit,
		javadoc <-javaDoc,
		anonymousClassDeclaration <- aCD
	),
	
	aCD: JavaAbstractSyntax!AnonymousClassDeclaration(
		bodyDeclarations<- Set{} 
	),
	
	nameLit:JavaAbstractSyntax!SimpleName(
		identifier<- name,
		fullyQualifiedName <- name 
	),
	
 	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- lit 
	 )
	
	do{
		enum.enumConstants <- enum.enumConstants->including(lit);
	}
}


------------------- Cria a classe Arbiter ----------------------------
rule createArbiter(pack: JavaAbstractSyntax!StructuralPackage){
	using{
		arb: uml2!Class = uml2!Class->allInstances()->select(e | e.name= 'Arbiter')->first();
	}
	to 
	comp: JavaAbstractSyntax!CompilationUnit(
	 	types<- Set{arbJ},
		package <- Config_Pack
	 ),
	 
	 Config_Pack: JavaAbstractSyntax!PackageDeclaration(
		name <- Config_Name ,
		javadoc <- javaDoc
	 ),
	
     Config_Name: JavaAbstractSyntax!SimpleName(
		identifier<- 'Config',
		fullyQualifiedName <- 'Config'
	 ), 
	
	 javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- Config_Pack 
	 ),
	
	arbJ : JavaAbstractSyntax!TypeDeclaration(
		name<- nameArbiter,
		modifiers <- modi,
		javadoc <- javaD,
--		---------------------------
		--superclassType <- sType,
		bodyDeclarations <- Set{}
	),
	
	modi: JavaAbstractSyntax!Modifier(
	 		public <- true
	),
	
	nameArbiter: JavaAbstractSyntax!SimpleName(
		identifier<- arb.name,
		fullyQualifiedName <-arb.name
	),
	
	 javaD: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{javadoc},
		alternateRoot <- arbJ
	 ),
	 
	 javadoc: JavaAbstractSyntax!TagElement(
	 	tagName <- 'ArbClass',
	 	nested <- true,
		fragments <- Sequence{javadocText}
	 ),
	 
	 javadocText: JavaAbstractSyntax!TextElement(
	 	text <- 'This code is automatically generated by the MoBIT Tool  
		@author Everton Leandro'
	 )
	 	
	do{
		uml2!Class->allInstances().toString().println();-->select(e | e.name= 'Arbiter')->first().toString().println();
		self.createAttributeArbiter(arbJ);
		self.createConstructArbiter(arbJ);
		self.createMethGetVerdictOfArbiter(arbJ);
		self.createMethSetVerdictOfArbiter(arbJ);
		self.createMethDefinesParcialVerdictOfArbiter(arbJ);
		thisModule.arbiter <- arb;
		thisModule.arbiterJ <- arbJ;
		
		pack.compilations <- pack.compilations->including(comp);
	
	}
}

rule createConstructArbiter(class: JavaAbstractSyntax!TypeDeclaration){
	to constr: JavaAbstractSyntax!MethodDeclaration(
			constructor <- true,
			name <- constName,
			modifiers <- modMeth,
			javadoc <- javaDoc,
			-------------------------------
			returnType <- returnNull,
			body <- blockConstArb
		),
		
		constName:JavaAbstractSyntax!SimpleName(
			identifier<- 'Arbiter',
			fullyQualifiedName <- 'Arbiter'
	    ),
		
		modMeth: JavaAbstractSyntax!Modifier(
	 		public <- true
		),
		
		javaDoc: JavaAbstractSyntax!Javadoc(
	 		tags <- Set{},
			alternateRoot <- constr 
	 	),
		
		returnNull : JavaAbstractSyntax!PrimitiveType(
			code <- 'void'
		),
				
		blockConstArb: JavaAbstractSyntax!Block(
			statements <-  Set{exp1, exp2}
		),
		
		exp1: JavaAbstractSyntax!ExpressionStatement(
			expression <- assig1
		),
		
		assig1: JavaAbstractSyntax!Assignment(
			operator<- #ASSIGN,
			leftHandSide <- verName,
			rightHandSide <- enumPass
		),
		
		verName:JavaAbstractSyntax!SimpleName(
			identifier<- 'verdict',
			fullyQualifiedName <- 'verdict'
	    ),
		
		enumPass: JavaAbstractSyntax!QualifiedName(
			qualifier <- enum,
			name <-  ePass,
			fullyQualifiedName <-''
		),
		
		enum:JavaAbstractSyntax!SimpleName(
			identifier<- thisModule.verdict.name.identifier,
			fullyQualifiedName <- thisModule.verdict.name.identifier
			
	    ),
		
		ePass:JavaAbstractSyntax!SimpleName(
			identifier<- 'pass',
			fullyQualifiedName <-'pass'
	    ) ,
		
		exp2: JavaAbstractSyntax!ExpressionStatement(
			expression <- assig2
		),
		
		assig2: JavaAbstractSyntax!Assignment(
			operator<- #ASSIGN,
			leftHandSide <- partialVerName,
			rightHandSide <- enumPass2
		),
		
		partialVerName:JavaAbstractSyntax!SimpleName(
			identifier<- 'partialVerdict' ,
			fullyQualifiedName <- 'partialVerdict'
	    ),
		
		enumPass2: JavaAbstractSyntax!QualifiedName(
			qualifier <- enum2,
			name <-  ePass2,
			fullyQualifiedName <-''
		),
		
		enum2:JavaAbstractSyntax!SimpleName(
			identifier<-  thisModule.verdict.name.identifier,
			fullyQualifiedName <- thisModule.verdict.name.identifier
	    ),
		
		ePass2:JavaAbstractSyntax!SimpleName(
			identifier<- 'pass',
			fullyQualifiedName <- 'pass'
	    ) 
	do{
			class.bodyDeclarations <- class.bodyDeclarations->including(constr);
	}
}


rule createMethSetVerdictOfArbiter(class: JavaAbstractSyntax!TypeDeclaration){
	to 
	methSetVerdict: JavaAbstractSyntax!MethodDeclaration(
		name <- nameSetVerdict ,
		returnType <- voidType,
		modifiers <- modMeth,
		javadoc <- javaDoc,
		parameters <- Sequence{bollParameter,intParameter},
		body <- blockSetVerdict
	),
	
	modMeth: JavaAbstractSyntax!Modifier(
	 	public <- true
	),
	
	voidType: JavaAbstractSyntax!PrimitiveType(
		code <- 'void'
	),
	
	nameSetVerdict: JavaAbstractSyntax!SimpleName(
		identifier<- 'setVerdict',
		fullyQualifiedName <- 'setVerdict'
	),
	
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- methSetVerdict 
	 ),
	
	bollParameter: JavaAbstractSyntax!SingleVariableDeclaration(
		name <- nameBoll,
		type <- bollType,
		initializer <- null
	),
	
	nameBoll: JavaAbstractSyntax!SimpleName(
		identifier<- 'v',
		fullyQualifiedName <- 'v'
		
	),
	
	bollType: JavaAbstractSyntax!PrimitiveType(
		code <-'boolean'
	),
	
	intParameter: JavaAbstractSyntax!SingleVariableDeclaration(
		name <- nameInt,
		type <- intType,
		initializer <- null2
	),
	
	null: JavaAbstractSyntax!NullLiteral,
	
	null2: JavaAbstractSyntax!NullLiteral,
	
	nameInt: JavaAbstractSyntax!SimpleName(
		identifier<- 'i',
		fullyQualifiedName <- 'i'
	),
	
	intType: JavaAbstractSyntax!PrimitiveType(
		code <-'int'
	),
	
	blockSetVerdict: JavaAbstractSyntax!Block(
		statements <-  IfFail
	),
	
	IfFail: JavaAbstractSyntax!IfStatement(
		expression <- IfFailInfix,
		thenStatement <- then1,
		elseStatement <- nullElse
	),
	
	nullElse: JavaAbstractSyntax!Block(
	 	statements <- Sequence{} 	 
	),
	
	IfFailInfix: JavaAbstractSyntax!InfixExpression(
		leftOperand <- namePartialVerdict0,
		rightOperand <- VerFail,
		operator <- #NOT_EQUALS
	),
	
	namePartialVerdict0: JavaAbstractSyntax!SimpleName(
		identifier<- 'partialVerdict',
		fullyQualifiedName <- 'partialVerdict'
	),
	
	VerFail: JavaAbstractSyntax!QualifiedName(
		qualifier<- verName,
		name <- failName,
		fullyQualifiedName <-''
	),
	
	verName: JavaAbstractSyntax!SimpleName(
		identifier<-  thisModule.verdict.name.identifier,
		fullyQualifiedName <- thisModule.verdict.name.identifier
	),
	
	failName: JavaAbstractSyntax!SimpleName(
		identifier<- 'fail',
		fullyQualifiedName <- 'fail'
	),
	
	then1: JavaAbstractSyntax!Block(
		statements <- Set{if2}
	),
	
	if2: JavaAbstractSyntax!IfStatement(
		expression <- infix2,
		thenStatement <- expStat2,
		elseStatement <- if3
	),
	
	infix2: JavaAbstractSyntax!InfixExpression(
		leftOperand <- vName,
		rightOperand <- boolTrue,
		operator <- #EQUALS
	),
	
	vName: JavaAbstractSyntax!SimpleName(
		identifier<- 'v',
		fullyQualifiedName <- 'v'
	),
	
	boolTrue: JavaAbstractSyntax!BooleanLiteral(
		booleanValue <- true
	),
	
	expStat2: JavaAbstractSyntax!ExpressionStatement(
		expression <- assign2
	),
	
	assign2: JavaAbstractSyntax!Assignment(
		leftHandSide <- namePartialVerdict1,
		operator <- #ASSIGN,
		rightHandSide <- VerFail2
	),
	
	namePartialVerdict1: JavaAbstractSyntax!SimpleName(
		identifier<- 'partialVerdict',
		fullyQualifiedName <- 'partialVerdict'
	),
	
	VerFail2: JavaAbstractSyntax!QualifiedName(
		qualifier<- verName2,
		name <- passName2,
		fullyQualifiedName <-''
	),
	
	verName2: JavaAbstractSyntax!SimpleName(
		identifier<-  thisModule.verdict.name.identifier,
		fullyQualifiedName <- thisModule.verdict.name.identifier
	),
	
	passName2: JavaAbstractSyntax!SimpleName(
		identifier<- 'pass',
		fullyQualifiedName <- 'pass'
	),
	
	if3: JavaAbstractSyntax!IfStatement(
		expression <- infix3,
		thenStatement <- expStat3,
		elseStatement <- if4
	),
	
	infix3: JavaAbstractSyntax!InfixExpression(
		leftOperand <- iName,
		rightOperand <- iZero,
		operator <- #EQUALS
	),
	
	iName: JavaAbstractSyntax!SimpleName(
		identifier<- 'i',
		fullyQualifiedName <- 'i'
	),
	
	iZero: JavaAbstractSyntax!NumberLiteral(
		token <- '0'
	),
	
	expStat3: JavaAbstractSyntax!ExpressionStatement(
		expression <- assign3
	),
	
	assign3: JavaAbstractSyntax!Assignment(
		leftHandSide <- namePartialVerdict2,
		operator <- #ASSIGN,
		rightHandSide <- VerFail3
	),
	
	namePartialVerdict2: JavaAbstractSyntax!SimpleName(
		identifier<- 'partialVerdict',
		fullyQualifiedName <- 'partialVerdict'
	),
	
	VerFail3: JavaAbstractSyntax!QualifiedName(
		qualifier<- verName3,
		name <- failName3,
		fullyQualifiedName <-''
	),
	
	verName3: JavaAbstractSyntax!SimpleName(
		identifier<-  thisModule.verdict.name.identifier,
		fullyQualifiedName <- thisModule.verdict.name.identifier
	),
	
	failName3: JavaAbstractSyntax!SimpleName(
		identifier<- 'fail',
		fullyQualifiedName <- 'fail'
	),
	
	if4: JavaAbstractSyntax!IfStatement(
		expression <- infix4,
		thenStatement <- expStat4,
		elseStatement <- expStat5
	),
	
	infix4: JavaAbstractSyntax!InfixExpression(
		leftOperand <- iName2,
		rightOperand <- iOne,
		operator <- #EQUALS
	),
	
	iName2: JavaAbstractSyntax!SimpleName(
		identifier<- 'i',
		fullyQualifiedName <- 'i'
	),
	
	iOne: JavaAbstractSyntax!NumberLiteral(
		token <- '1'
	),
	
	expStat4: JavaAbstractSyntax!ExpressionStatement(
		expression <- assign4
	),
	
	assign4: JavaAbstractSyntax!Assignment(
		leftHandSide <- namePartialVerdict3,
		operator <- #ASSIGN,
		rightHandSide <- Ver4
	),
	
	namePartialVerdict3: JavaAbstractSyntax!SimpleName(
		identifier<- 'partialVerdict',
		fullyQualifiedName <- 'partialVerdict'
	),
	
	Ver4: JavaAbstractSyntax!QualifiedName(
		qualifier<- verName4,
		name <- inconclusName4,
		fullyQualifiedName <-''
	),
	
	verName4: JavaAbstractSyntax!SimpleName(
		identifier<-  thisModule.verdict.name.identifier,
		fullyQualifiedName <- thisModule.verdict.name.identifier
	),
	
	inconclusName4: JavaAbstractSyntax!SimpleName(
		identifier<- 'inconclusive',
		fullyQualifiedName <- 'inconclusive'
	),
	
	expStat5: JavaAbstractSyntax!ExpressionStatement(
		expression <- assign5
	),
	
	assign5: JavaAbstractSyntax!Assignment(
		leftHandSide <- namePartialVerdict4,
		operator <- #ASSIGN,
		rightHandSide <- Ver5
	),
	
	namePartialVerdict4: JavaAbstractSyntax!SimpleName(
		identifier<- 'partialVerdict',
		fullyQualifiedName <- 'partialVerdict'
	),
	
	Ver5: JavaAbstractSyntax!QualifiedName(
		qualifier<- verName5,
		name <- errorName5,
		fullyQualifiedName <-''
	),
	
	verName5: JavaAbstractSyntax!SimpleName(
		identifier<-  thisModule.verdict.name.identifier,
		fullyQualifiedName <- thisModule.verdict.name.identifier
	),
	
	errorName5: JavaAbstractSyntax!SimpleName(
		identifier<- 'error',
		fullyQualifiedName <- 'error'
	)
	
	do{
		class.bodyDeclarations <- class.bodyDeclarations->including(methSetVerdict);
	}
}


rule createMethDefinesParcialVerdictOfArbiter(class: JavaAbstractSyntax!TypeDeclaration){
	to 
	methDefinesParcialVerdict: JavaAbstractSyntax!MethodDeclaration(
		name <- nameDefinesParcialVerdict,
		returnType <- voidType,
		modifiers <- modMeth,
		javadoc <- javaDoc,
		body <- blockDefinesParcialVerdict
	),
	
	modMeth: JavaAbstractSyntax!Modifier(
	 	public <- true
	),
	
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- methDefinesParcialVerdict 
	 ),
	
	voidType: JavaAbstractSyntax!PrimitiveType(
		code <- 'void'
	),
	
	nameDefinesParcialVerdict: JavaAbstractSyntax!SimpleName(
		identifier<- 'definesPartialVerdict',
		fullyQualifiedName <- 'definesPartialVerdict'
	),
	
	blockDefinesParcialVerdict: JavaAbstractSyntax!Block(
		statements <-  exp
	),
	
	exp: JavaAbstractSyntax!ExpressionStatement(
		expression <- assig
	),
	
	assig: JavaAbstractSyntax!Assignment(
		leftHandSide <- nameVerdict,
		operator<- #ASSIGN,
		rightHandSide <- namePartialVerdict
	),
	
	nameVerdict: JavaAbstractSyntax!SimpleName(
		identifier<- 'verdict',
		fullyQualifiedName <- 'verdict'
	),
	
	namePartialVerdict: JavaAbstractSyntax!SimpleName(
		identifier<- 'partialVerdict',
		fullyQualifiedName <- 'partialVerdict'
	)
	
	do{
		class.bodyDeclarations <- class.bodyDeclarations->including(methDefinesParcialVerdict);
	}
}


rule createMethGetVerdictOfArbiter(class: JavaAbstractSyntax!TypeDeclaration){
	to 
	methGetVerdict: JavaAbstractSyntax!MethodDeclaration(
		name <- nameGetVerdict ,
		returnType <- typeVerdict,
		modifiers <- modMeth,
		javadoc <- javaDoc,
		body <- blockGetVerdict
	),
	
	modMeth: JavaAbstractSyntax!Modifier(
	 	public <- true
	),
	
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- methGetVerdict 
	),
		
	nameGetVerdict: JavaAbstractSyntax!SimpleName(
		identifier<- 'getVerdict',
		fullyQualifiedName <- 'getVerdict'
	),
	
	typeVerdict:  JavaAbstractSyntax!SimpleType(
		name <- TypeVerdictName
	),
	
	TypeVerdictName: JavaAbstractSyntax!SimpleName(
		identifier<- thisModule.verdict.name.identifier,
		fullyQualifiedName <- thisModule.verdict.name.identifier
	),
	
	blockGetVerdict: JavaAbstractSyntax!Block(
		statements <-  returnGetVerdict
	),
	
	returnGetVerdict: JavaAbstractSyntax!ReturnStatement(
		expression<- ver
	),
	
	ver:  JavaAbstractSyntax!SimpleName(
		identifier<- 'verdict',
		fullyQualifiedName <- 'verdict'
	)
	
	do{
		class.bodyDeclarations <- class.bodyDeclarations->including(methGetVerdict);
	}
}


rule createAttributeArbiter(class: JavaAbstractSyntax!TypeDeclaration){
	using{
		
	} 
	to attribute1: JavaAbstractSyntax!FieldDeclaration(
		type <- typeVerdict,
		fragments <- Set{ at1Exp },
		javadoc <- javaDoc,
		modifiers<- visibylity 
	),
	
	typeVerdict:  JavaAbstractSyntax!SimpleType(
		name <- TypeVerdictName
	),
	
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- attribute1 
	),
	
	TypeVerdictName: JavaAbstractSyntax!SimpleName(
		identifier<- thisModule.verdict.name.identifier,
		fullyQualifiedName <- thisModule.verdict.name.identifier
	),
	
	visibylity: JavaAbstractSyntax!Modifier(
		private <- true
	),
	
	at1Exp:JavaAbstractSyntax!VariableDeclarationFragment(
		name <- simpleNameAt1,
		initializer <- null
	),
	
	null: JavaAbstractSyntax!NullLiteral,
		
	simpleNameAt1: JavaAbstractSyntax!SimpleName(
		identifier<- 'verdict',
		fullyQualifiedName <- 'verdict' 
	),
	
	attribute2: JavaAbstractSyntax!FieldDeclaration(
		type <- typeVerdict2,
		fragments <- Set{ at2Exp },
		javadoc <- javaDoc2,
		modifiers<- visibylity2
	),
	
	javaDoc2: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- attribute2
	),
	
	typeVerdict2:  JavaAbstractSyntax!SimpleType(
		name <- TypeVerdictName2
	),
	
	TypeVerdictName2: JavaAbstractSyntax!SimpleName(
		identifier<- thisModule.verdict.name.identifier,
		fullyQualifiedName <- thisModule.verdict.name.identifier
	),
		
	visibylity2: JavaAbstractSyntax!Modifier(
		private <- true
	),
	
	at2Exp:JavaAbstractSyntax!VariableDeclarationFragment(
		name <- simpleNameAt2,
		initializer <- null2
	),
	
	null2: JavaAbstractSyntax!NullLiteral,
		
	simpleNameAt2: JavaAbstractSyntax!SimpleName(
		identifier<- 'partialVerdict',
		fullyQualifiedName <- 'partialVerdict'
	)
	 
	do{
		class.bodyDeclarations <- class.bodyDeclarations->including(attribute1)->including(attribute2);
	}
}

rule CreateBIT(){
	using{

		cont:Set(uml2!Class) = uml2!Class->allInstances()->select(c | c.getAppliedStereotypes()->exists(s|s.name='Context'))->first();
		v1 : Sequence(uml2!Property) = uml2!Association->allInstances()->select(a | a.memberEnd->exists(me | me.type = cont))->collect(a | a.memberEnd)->flatten()->select(me|me.type<> cont);
		v2 : Sequence(String) = uml2!Property->allInstances()->select( p | uml2!Association->allInstances()->select(a | a.memberEnd->exists(me | me.type = cont))->collect(a | a.memberEnd)->flatten()->select(me|me.type <> cont)->includes(p))->collect(p|p.type);
		
		ass: Sequence(uml2!Association) = uml2!Association->allInstances()->select(a | a.memberEnd->exists(me | me.type = cont))->collect(m | m.memberEnd->collect(c | c.type))->flatten()->excluding(cont);
		assocWithContx: Sequence(uml2!Association) = uml2!Association->allInstances()->select(a | a.memberEnd->exists(me | me.type = cont))->collect(a | a.memberEnd)->flatten()->select(c | c.type <> cont);
		allAss: Sequence(uml2!Association) = uml2!Association->allInstances()->select(a | a.memberEnd->size()>0);
		
	}
	
	do{		

		for (ass in assocWithContx){
			for (ass2 in assocWithContx){
				if (ass.type.name <> ass2.type.name){
					thisModule.set<-Sequence{ass.type};
					thisModule.set<-thisModule.set->including(ass2.type);
					--thisModule.set.toString().println();
					for (a in allAss){
						if ( (a.memberEnd->collect(c | c.type.name)->includes(thisModule.set->at(1).name) ) and  (a.memberEnd->collect(c | c.type.name)->includes(thisModule.set->at(2).name) )){
							thisModule.servers<- thisModule.servers->including(a.memberEnd->at(2).type);
						}
					}
				}				
			}
		}
		
		for (c in v2){
			if (not thisModule.servers->includes(c))
				thisModule.clients<- thisModule.clients->including(c);
		}
		
		self.configure(cont);
		
	} 
}
	
rule configure(contx : uml2!Class){
	using{
		packs: Set(uml2!Package) = uml2!Package->allInstances()->select(p | p.ownedMember ->exists(i | i.getAppliedStereotypes()->exists(s|s.name='Testing Component')));
		clients: Set(String) = thisModule.clients->collect(c | c.name)->asSet(); 
		servers: Set(String) = thisModule.servers->collect(c | c.name)->asSet();
	}	
	do{
		
		for (pack in packs){
			thisModule.testing<- pack.ownedMember->select(e | e.oclIsTypeOf(uml2!Class))->select(s | s.superClass->size()>0)->select(s | s.superClass->collect(n | n.name)->asSet()->intersection(clients)->size()>0);
			thisModule.testable<- pack.ownedMember->select(e | e.oclIsTypeOf(uml2!Class))->select(s | s.superClass->size()>0)->select(s | s.superClass->collect(n | n.name)->asSet()->intersection(servers)->size()>0);
			
			thisModule.client <- thisModule.testing->first().superClass->first();
			thisModule.server <- thisModule.testable->first().superClass->first();
			thisModule.tester <-pack.ownedMember->select(a | a.oclIsTypeOf(uml2!Association))->select(a | a.memberEnd->collect(t | t.type.name)->includes( thisModule.testing->first().name))->first().memberEnd->collect(t | t.type)->select(n | n.name <> thisModule.testing->first().name)->first();
	
			self.createStrctBIT(pack);
		}

	}
}

rule createStrctBIT(pack: uml2!Package){
	to
	packBIT: JavaAbstractSyntax!StructuralPackage(
	 	compilations <- Set{},
		name <- 'BITPack'+ (thisModule.number + 1).toString()
	)
	
	do{
		thisModule.number <- thisModule.number + 1;
		self.CreateClassTesting(packBIT, pack, thisModule.client);
		self.createTestable(packBIT,pack, thisModule.server);
		self.createTester(packBIT,pack, thisModule.tester);
		thisModule.strcPack.structuralPackages <- thisModule.strcPack.structuralPackages->including(packBIT);
	}
}

rule CreateClassTesting (pBIT:JavaAbstractSyntax!StructuralPackage, pack: uml2!Package, client:uml2!Class){ 
	using{		
		class: Set(uml2!Class) = pack.packagedElement->select(e | e.oclIsTypeOf(uml2!Class))->select(c | c.ownedOperation->exists(o | o.name = 'setTester'))->first();		
	}
	--Criação da classe Java TestingClient
	to 
	unit: JavaAbstractSyntax!CompilationUnit(
		types<- Set{typeTest},
		package <- BIT_Pack
	),
	
	BIT_Pack: JavaAbstractSyntax!PackageDeclaration(
		name <- BIT_Name ,
		javadoc <- javaDoc
	),
	
	BIT_Name: JavaAbstractSyntax!SimpleName(
		identifier<- 'BIT',
		fullyQualifiedName <- 'BIT'
	), 
	
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- BIT_Pack 
	),
	
	typeTest :JavaAbstractSyntax!TypeDeclaration (
		name<-nameClass,
		superclassType <- typeClient,
		modifiers<- visibylity,
		javadoc <- javaD,
		bodyDeclarations <- Set{}

	),
	
	nameClass:JavaAbstractSyntax!SimpleName(
		identifier<- class.name,
		fullyQualifiedName <- 'BIT.'+class.name
	),
	
	typeClient: JavaAbstractSyntax!SimpleType(
		name <- TypeClientName
	),
	
	TypeClientName: JavaAbstractSyntax!SimpleName(
		identifier<- client.name,
		fullyQualifiedName <- 'BIT.'+ client.name
	), 
	
	visibylity: JavaAbstractSyntax!Modifier(
		public <- true
	), 
	
	javaD: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{javadoc},
		alternateRoot <- typeTest
	),
	 
	javadoc: JavaAbstractSyntax!TagElement(
		tagName <- 'ArbClass',
		nested <- true,
		fragments <- Sequence{javadocText}
	),
	 
	javadocText: JavaAbstractSyntax!TextElement(
		text <- 'This code is automatically generated by the MoBIT Tool
		@author Everton Leandro'
	)
	
	do{
		self.createAtributesTesting(typeTest, thisModule.client, thisModule.server, thisModule.tester);
		self.createMethodSetTester(typeTest);
		self.createMethodSetServer(typeTest);
		self.createMethodPerform(typeTest);
		
		pBIT.compilations <- pBIT.compilations->including(unit); 
		
	}
	
}

rule createAtributesTesting(class:JavaAbstractSyntax!TypeDeclaration, client:uml2!Class, server:uml2!Class, tester:uml2!Class ){
	using{
		testable: uml2!Class = thisModule.testable->first();
	}
	to -- Inicialização dos atributos da classe
	attribute1: JavaAbstractSyntax!FieldDeclaration(
		type <- typeServer,
		modifiers<- visibylity,
		javadoc <- javaDoc,
		fragments<- Sequence{var1}
	),
	
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- attribute1 
	),
	
	var1: JavaAbstractSyntax!VariableDeclarationFragment(
		name <- simpleNameAt1,
		initializer <- null0
	),
		
	null0: JavaAbstractSyntax!NullLiteral,
	
	typeServer:  JavaAbstractSyntax!SimpleType(
		name <- TypeServerName
	),
	
	TypeServerName: JavaAbstractSyntax!SimpleName(
		identifier<- testable.name,
		fullyQualifiedName <- 'BIT.'+ testable.name
	),
	
	visibylity: JavaAbstractSyntax!Modifier(
		private <- true
	),
	
	simpleNameAt1: JavaAbstractSyntax!SimpleName(
		identifier<- 'server',
		fullyQualifiedName <- 'BIT.server'
	),
	
	attribute2: JavaAbstractSyntax!FieldDeclaration(
		type <- typeTester,
		fragments <- Set{ at2Exp },
		javadoc <- javaDoc2, 
		modifiers<- visibylity2
	),
	
	javaDoc2: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- attribute2 
	),
	
	typeTester:  JavaAbstractSyntax!SimpleType(
		name <- TypeTesterName
	),
	
	TypeTesterName: JavaAbstractSyntax!SimpleName(
		identifier<- tester.name,
		fullyQualifiedName <- 'BIT.'+ tester.name
	),
		
	at2Exp:JavaAbstractSyntax!VariableDeclarationFragment(
		name <- simpleNameAt2,
		initializer <- null
	),
		
	null: JavaAbstractSyntax!NullLiteral,
	
	simpleNameAt2: JavaAbstractSyntax!SimpleName(
		identifier<- 'tester',
		fullyQualifiedName <- 'BIT.tester'
	),
	
	attribute3: JavaAbstractSyntax!FieldDeclaration(
		type <- typeVerdict,
		fragments <- Set{ at3Exp },
		javadoc <- javaDoc3,
		modifiers<- visibylity3
	),
	
	javaDoc3: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- attribute1 
	),
	
	visibylity2: JavaAbstractSyntax!Modifier(
		private <- true
	),
	
	typeVerdict:  JavaAbstractSyntax!SimpleType(
		name <- TypeVerdictName
	),
	
	TypeVerdictName: JavaAbstractSyntax!SimpleName(
		identifier<- thisModule.verdict.name.identifier,
		fullyQualifiedName <- 'BIT.'+ thisModule.verdict.name.identifier
	),
		
	at3Exp: JavaAbstractSyntax!VariableDeclarationFragment(
		name <- simpleNameAt3,
		initializer <- null2
	),
		
	null2: JavaAbstractSyntax!NullLiteral,
	
	visibylity3: JavaAbstractSyntax!Modifier(
		private <- true
	),
		
	simpleNameAt3: JavaAbstractSyntax!SimpleName(
		identifier<- 'verdict',
		fullyQualifiedName <- 'BIT.verdict'
	)
	do{
		class.bodyDeclarations <- class.bodyDeclarations->including(attribute1)->including(attribute2)->including(attribute3);
	}
}

 --Cria metodo setTester
rule createMethodSetTester( typeTest: JavaAbstractSyntax!TypeDeclaration){
	using{
	
	}
	to method: JavaAbstractSyntax!MethodDeclaration (
		name <- simpleName , 
	 	body <- blockMeth,
		modifiers <- modMeth,
		javadoc <- javaDoc,
		returnType <- voidType,
		parameters <- testerParameter
	),
	
	voidType: JavaAbstractSyntax!PrimitiveType(
		code <- 'void'
	),
	
	simpleName: JavaAbstractSyntax!SimpleName(
		identifier<-'setTester',
		fullyQualifiedName <- 'BIT.setTester'
	),
	
	modMeth: JavaAbstractSyntax!Modifier(
	 	public <- true
	),
	
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- method 
	),
	
	blockMeth: JavaAbstractSyntax!Block (
		statements<- Set{}->including(expr)
	),

	expr: JavaAbstractSyntax!ExpressionStatement(
		expression <- assig 
	),
	
	assig: JavaAbstractSyntax!Assignment(
		leftHandSide<- var,
		operator<- #ASSIGN,
		rightHandSide<- value
	),
	
	var:JavaAbstractSyntax!SimpleName(
		identifier<-'tester',
		fullyQualifiedName <- 'BIT.tester'
	),
	
	value: JavaAbstractSyntax!SimpleName(
		identifier<-'t',
		fullyQualifiedName <- 'BIT.t'
	),

	testerParameter: JavaAbstractSyntax!SingleVariableDeclaration(
		name <- nameParameter,
		type <- testerType,
		initializer <- null
	),
	
	null: JavaAbstractSyntax!NullLiteral,
	
	nameParameter: JavaAbstractSyntax!SimpleName(
		identifier<- 't',
		fullyQualifiedName <- 'BIT.t'
	),
	
	testerType:  JavaAbstractSyntax!SimpleType(
		name <- testerTypeName
	),
	
	testerTypeName: JavaAbstractSyntax!SimpleName(
		identifier<- thisModule.tester.name,
		fullyQualifiedName <- 'BIT'+thisModule.tester.name
	)
		
	do{
		typeTest.bodyDeclarations<-typeTest.bodyDeclarations->including(method);
	}
}
-- Cria metodo setServer
rule createMethodSetServer( typeTest: JavaAbstractSyntax!TypeDeclaration ){
using{
	testable: uml2!Class = thisModule.testable->first();
	
}
to method: JavaAbstractSyntax!MethodDeclaration (
		name <- simpleName , 
	 	body <- blockMeth,
		modifiers <- modMeth,
		javadoc <- javaDoc,
		returnType <- voidType,
		parameters <- testerParameter
	),
	
	voidType: JavaAbstractSyntax!PrimitiveType(
		code <- 'void'
	),
	
	simpleName: JavaAbstractSyntax!SimpleName(
		identifier<-'setServer',
		fullyQualifiedName <- 'BIT.setServer' 
	),
	
	modMeth: JavaAbstractSyntax!Modifier(
	 	public <- true
	),
	
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- method 
	),
	
	blockMeth: JavaAbstractSyntax!Block (
		statements<- Set{}->including(expr)
	),
	
	expr: JavaAbstractSyntax!ExpressionStatement(
		expression <- assig 
	),
	
	assig: JavaAbstractSyntax!Assignment(
		leftHandSide<- var,
		operator<- #ASSIGN,
		rightHandSide<- value
	),
	
	var:JavaAbstractSyntax!SimpleName(
		identifier<-'server',
		fullyQualifiedName <- 'BIT.server'
	),
	
	value: JavaAbstractSyntax!SimpleName(
		identifier<-'s',
		fullyQualifiedName <- 'BIT.s'
	),
	
	testerParameter: JavaAbstractSyntax!SingleVariableDeclaration(
		name <- nameParameter,
		type <- testerType,
		initializer <- null
	),
	
	null: JavaAbstractSyntax!NullLiteral,
	
	nameParameter: JavaAbstractSyntax!SimpleName(
		identifier<-'s',
		fullyQualifiedName <- 'BIT.s'
	),
	
	testerType:  JavaAbstractSyntax!SimpleType(
		name <- testerTypeName
	),
	
	testerTypeName: JavaAbstractSyntax!SimpleName(
		identifier<- testable.name,
		fullyQualifiedName <- 'BIT'+ testable.name
	)
		
	do{
		
		typeTest.bodyDeclarations<-typeTest.bodyDeclarations->including(method);
	}
}

-- Cria metodo perforTest
rule createMethodPerform( typeTest: JavaAbstractSyntax!TypeDeclaration ){
using{
	
}
to method: JavaAbstractSyntax!MethodDeclaration (
		name<- simpleName,
		returnType <- voidType,
		modifiers <- modMeth,
		javadoc <- javaDoc,
		body <- block
	),
	
	modMeth: JavaAbstractSyntax!Modifier(
	 	public <- true
	),
	
	voidType: JavaAbstractSyntax!PrimitiveType(
		code <- 'void'
	),
	
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- method 
	),	
	
	simpleName: JavaAbstractSyntax!SimpleName(
		identifier<-'performTest',
		fullyQualifiedName <- 'BIT.performTest'
	),
	
	block: JavaAbstractSyntax!Block (
		statements<- Set{}->including(ifStat1)
	),
	
	ifStat1:JavaAbstractSyntax!IfStatement(
		expression<- inFix1,
		thenStatement<-blockIF,
		elseStatement <- nullElse
	),
	
	nullElse: JavaAbstractSyntax!Block(
	 	statements <- Sequence{} 	 
	),
	
	blockIF: JavaAbstractSyntax!Block(
		statements <- Set{}->including(expStat)
	),	
	
	expStat: JavaAbstractSyntax!ExpressionStatement(
		expression <- assign
	),
	
	assign: JavaAbstractSyntax!Assignment(
		leftHandSide <- nameVerdict,
		operator<- #ASSIGN,
		rightHandSide <- invocationMethod
	),
	
	nameVerdict: JavaAbstractSyntax!SimpleName(
		identifier<- 'verdict',
		fullyQualifiedName <- 'BIT.verdict'
	),
	
	invocationMethod: JavaAbstractSyntax!MethodInvocation(
		expression <- testerName2,
		name <- methodName,
		arguments <- Set{servName2}	
	),
	
	methodName: JavaAbstractSyntax!SimpleName(
		identifier<- 'executeTest',
		fullyQualifiedName <- 'BIT.executeTest'
	),
	
	inFix1: JavaAbstractSyntax!InfixExpression(
		leftOperand<- parenthExp,
		operator <-#CONDITIONAL_AND,
		rightOperand <- parenthExp2
	),
	
	parenthExp2: JavaAbstractSyntax!ParenthesizedExpression(
		expression <- inFix3
	),
	
	inFix3: JavaAbstractSyntax!InfixExpression(
		leftOperand<- testerName,
		operator <-#NOT_EQUALS,
		rightOperand <- null2
	),
	
	testerName: JavaAbstractSyntax!SimpleName(
		identifier<- 'tester',
		fullyQualifiedName <- 'BIT.executeTest'
	),
	
	testerName2: JavaAbstractSyntax!SimpleName(
		identifier<- 'tester',
		fullyQualifiedName <- 'BIT.tester'
	),
	
	null2: JavaAbstractSyntax!NullLiteral(
	
	),
	
	parenthExp: JavaAbstractSyntax!ParenthesizedExpression(
		expression <- inFix2
	),
	
	inFix2: JavaAbstractSyntax!InfixExpression(
		leftOperand<- servName,
		operator <-#NOT_EQUALS,
		rightOperand <- null
	),
	
	servName: JavaAbstractSyntax!SimpleName(
		identifier<- 'server',
		fullyQualifiedName <- 'BIT.server'
	),
	
	servName2: JavaAbstractSyntax!SimpleName(
		identifier<- 'server',
		fullyQualifiedName <- 'BIT.server'
	),
	
	null: JavaAbstractSyntax!NullLiteral(
	
	)

	do{
		typeTest.bodyDeclarations<-typeTest.bodyDeclarations->including(method);	
	
	}
}

rule createTestable (pBIT:JavaAbstractSyntax!StructuralPackage, pack: uml2!Package, server: uml2!Class){
	using{
	operTestable : Set(uml2!Operation) = thisModule.testable->first().ownedOperation;
	}
	to 
	unit: JavaAbstractSyntax!CompilationUnit(
		types<- Set{testableServer},
		package <- BIT_Pack
	),
	
	BIT_Pack: JavaAbstractSyntax!PackageDeclaration(
		name <- BIT_Name ,
		javadoc <- javaDoc
	),
	
	BIT_Name: JavaAbstractSyntax!SimpleName(
		identifier<- 'BIT',
		fullyQualifiedName <- 'BIT'
	), 
	
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- BIT_Pack 
	),
	
	testableServer: JavaAbstractSyntax!TypeDeclaration(
			name<- nameTestable,	
			superclassType <- serv,
			modifiers <- modMeth,
			javadoc <- javaD,
			bodyDeclarations <- Set{}
	),
	
	modMeth: JavaAbstractSyntax!Modifier(
	 	public <- true
	),
	
	javaD: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{javadoc},
		alternateRoot <- testableServer
	),
	 
	javadoc: JavaAbstractSyntax!TagElement(
		tagName <- 'ArbClass',
		nested <- true,
		fragments <- Sequence{javadocText}
	),
	 
	javadocText: JavaAbstractSyntax!TextElement(
		text <- 'This code is automatically generated by the MoBIT Tool
		@author Everton Leandro'
	),
	
	nameTestable:JavaAbstractSyntax!SimpleName(
		identifier<-'Testable'.concat(server.name),
		fullyQualifiedName <- 'BIT.'+'Testable'.concat(server.name)
	),
	
	serv: JavaAbstractSyntax!SimpleType(
		name <- serverTypeName
	),
	
	serverTypeName: JavaAbstractSyntax!SimpleName(
		identifier<- thisModule.server.name,
		fullyQualifiedName <- 'BIT.'+thisModule.server.name
	)
	
	do{
		for (o in operTestable){
			if (o.name.substring(1,4)= 'isIn')
				self.createMethIsIn(testableServer, o);
			else
				if (o.name.substring(1,5)= 'setTo')
					self.createMethSetTo(testableServer, o);
		}
		
--		for (o in operTestable){
--			if (o.name.substring(1,4)= 'isIn') 
--				self.createMethIsInGeneric(testableServer, o);
--			else if (o.name.substring(1,5)= 'setTo')  
--					self.createMethSetToGeneric(testableServer, o);
--		}
		
		pBIT.compilations <- pBIT.compilations->including(unit);
	}
}

rule createMethIsIn(testableServer:JavaAbstractSyntax!typeDeclaration, op : uml2!Operation ){
	using{
		length: Integer = op.name->size();
	}
	to
	meth: JavaAbstractSyntax!MethodDeclaration(
		name <- nameMeth,
	 	body <- blockMeth,
		modifiers <- modMeth,
		javadoc <- javaDoc,
		returnType <- boolType
	),
	
	nameMeth:JavaAbstractSyntax!SimpleName(
	 	identifier <- op.name,
		fullyQualifiedName <- 'BIT.'+op.name
	),
	
	modMeth: JavaAbstractSyntax!Modifier(
	 	public <- true
	),
	
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- meth 
	),
	
	boolType: JavaAbstractSyntax!PrimitiveType(
		code <- 'boolean'
	),
	
	blockMeth: JavaAbstractSyntax!Block(
		statements <- Sequence{}->including(methBody)
	),
	
	methBody : JavaAbstractSyntax!ReturnStatement(
		expression <- invocMeth
	),
	
	invocMeth:JavaAbstractSyntax!MethodInvocation(
	 	expression <- invoc,
		name <- equalsName,
		arguments <- stateName
	),
	
	invoc: JavaAbstractSyntax!MethodInvocation(
		name <- getStateName,
		expression <- null
	),
	
	null: JavaAbstractSyntax!NullLiteral(
	
	),
	
	getStateName: JavaAbstractSyntax!SimpleName(
		identifier <- 'getState',
		fullyQualifiedName <- 'BIT.getState'
	),
	
	equalsName: JavaAbstractSyntax!SimpleName(
		identifier <- 'equals',
		fullyQualifiedName <- 'equals'
	),
	
	stateName: JavaAbstractSyntax!StringLiteral(
		literalValue <- '',
		escapedValue <- op.name.substring(5,length)
	)
	
	do{
		testableServer.bodyDeclarations <- testableServer.bodyDeclarations->including(meth);
	}
}

rule createMethIsInGeneric(testableServer:JavaAbstractSyntax!typeDeclaration, op : uml2!Operation ){
	to
	meth: JavaAbstractSyntax!MethodDeclaration(
		name <- nameMeth,
       	modifiers <- modMeth,
		javadoc <- javaDoc,
		body <- blockDefault,
		returnType <- boolType
	),
	
	nameMeth:JavaAbstractSyntax!SimpleName(
	 	identifier <- op.name,
		fullyQualifiedName <- 'BIT.'+op.name
	),
	
	 modMeth: JavaAbstractSyntax!Modifier(
	 	public <- true
	 ),
	 
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- meth 
	),
	
	boolType: JavaAbstractSyntax!PrimitiveType(
		code <- 'boolean'
	),
	
	blockDefault:JavaAbstractSyntax!Block(
		statements <- Set{}->including(returnDefault)
	),
	
	returnDefault: JavaAbstractSyntax!ReturnStatement(
		expression <- boolTrue
	),
	
	boolTrue:  JavaAbstractSyntax!BooleanLiteral(
		booleanValue <- true
	)
	
	do{
		testableServer.bodyDeclarations <- testableServer.bodyDeclarations->including(meth);
	}
}


rule createMethSetTo(testableServer:JavaAbstractSyntax!typeDeclaration, op : uml2!Operation ){
	using{
		length: Integer = op.name->size();
		SMServer: uml2!StateMachine = uml2!StateMachine->allInstances()->select(s | s.name = thisModule.server.name)->first();
		state: uml2!State = SMServer.region->first().getSubvertices()->select(s | s.name = op.name.substring(6,length))->first();
		transOUT: Set(uml2!Transition) = uml2!Transition->allInstances()->select(t | t.source.name = state.name);--.getOutgoings();
		transOUTWhithGuard: Set(uml2!Transition) = transOUT->select(t | t.getGuard().oclIsUndefined() = false);
		
	}
	to meth: JavaAbstractSyntax!MethodDeclaration(
		name <- nameMeth,
	 	body <- blockMeth,
		javadoc <- javaDoc,
		returnType <- voidType,
		modifiers<- modMeth,
		parameters <- Set{}
	),
	
	voidType: JavaAbstractSyntax!PrimitiveType(
		code <- 'void'
	),
	
	nameMeth:JavaAbstractSyntax!SimpleName(
	 	identifier <- op.name,
		fullyQualifiedName <- 'BIT.'+op.name
	),
	
	modMeth: JavaAbstractSyntax!Modifier(
	 	public <- true
	),
	
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- meth 
	),
	
	blockMeth: JavaAbstractSyntax!Block(
		statements <- Sequence{}
	),
	
	methSetTo : JavaAbstractSyntax!ExpressionStatement(
		expression <- invocMeth
	),
	
	invocMeth: JavaAbstractSyntax!MethodInvocation(
		name <- setStateName,
		arguments <- Set{}->including(nameState),
		expression <- null
	),
	
	null: JavaAbstractSyntax!NullLiteral(
	
	),
	
	setStateName: JavaAbstractSyntax!SimpleName(
		identifier <- 'setState',
		fullyQualifiedName <- 'BIT.setState'
	),
	
	nameState: JavaAbstractSyntax!StringLiteral(
		literalValue <- '',
		escapedValue<- op.name.substring(6,length)
	)

	do{
		--transOUT.toString().println();
		for (p in op.ownedParameter){
			 self.createOpParameter(meth, p);
		}
		thisModule.numberOfSituations<- 0;
		for (t in transOUTWhithGuard){
			self.createIfSituation(blockMeth, t.getGuard().getSpecification().stringValue());
		}
		blockMeth.statements <- blockMeth.statements->including(methSetTo);
		testableServer.bodyDeclarations <- testableServer.bodyDeclarations->including(meth);
	}
}


rule createIfSituation(b: JavaAbstractSyntax!Block, guard: String){
	to
	is: JavaAbstractSyntax!IfStatement(
		expression <- mi,
		elseStatement <- be
	),
	
	mi: JavaAbstractSyntax!MethodInvocation(
		expression <- snv, 
		name <- sn,
		arguments <- Set{sl}
	),
	
	sl: JavaAbstractSyntax!StringLiteral(
		escapedValue <- guard
	),
	
	sn: JavaAbstractSyntax!SimpleName(
		identifier <- 'equals'
	),
	
	snv: JavaAbstractSyntax!SimpleName(
		identifier <- 'situation'
	),
	
	be: JavaAbstractSyntax!Block(
		statements <- Set{}
	)
	
	do{
		if (thisModule.numberOfSituations = 0){
			b.statements <- b.statements->including(is);
			thisModule.numberOfSituations<- thisModule.numberOfSituations + 1;
		}else{
			thisModule.elseSituation.statements <- thisModule.elseSituation.statements->including(is); 
		}
		thisModule.elseSituation <- be;
	}
}

rule createOpParameter(meth: JavaAbstractSyntax!MethodDeclaration, p : uml2!Parameter ){
	to
	svd: JavaAbstractSyntax!SingleVariableDeclaration(
		type <- tp,
		name <- sn 
	),
		
	tp: JavaAbstractSyntax!SimpleType(
		name <- snt
	),
	
	snt: JavaAbstractSyntax!SimpleName(
		identifier <- 'String'
	),
	
	sn: JavaAbstractSyntax!SimpleName(
		identifier <- p.name	
	)
	do{
		meth.parameters <- meth.parameters->including(svd); 
	}
}

rule createMethSetToGeneric(testableServer:JavaAbstractSyntax!typeDeclaration, op : uml2!Operation ){
	using{
		length: Integer = op.name->size();
	}
	
	to meth: JavaAbstractSyntax!MethodDeclaration(
		name <- nameMeth,
		returnType <- voidType,
		body <- block,
	 	modifiers<- modMeth,
		javadoc <- javaDoc
	),
	
	voidType: JavaAbstractSyntax!PrimitiveType(
		code <- 'void'
	),
	
	nameMeth:JavaAbstractSyntax!SimpleName(
	 	identifier <- op.name,
		fullyQualifiedName <- 'BIT.'+ op.name
	),
	
	modMeth: JavaAbstractSyntax!Modifier(
	 	public <- true
	 ),
	
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- meth 
	),
	 
	block: JavaAbstractSyntax!Block(
	
	)
	 
	do{
		testableServer.bodyDeclarations <- testableServer.bodyDeclarations->including(meth);
	}
}


rule createTester(pBIT:JavaAbstractSyntax!StructuralPackage, pack: uml2!Package, t: uml2!Class){
	using{
		cols: Sequence(uml2!Collaboration)= pack.packagedElement->select(e | e.oclIsTypeOf(uml2!Collaboration));
		
	} 
	to 
	unit: JavaAbstractSyntax!CompilationUnit(
		types<- Set{tester},
		package <- BIT_Pack
	),
	
		BIT_Pack: JavaAbstractSyntax!PackageDeclaration(
		name <- BIT_Name ,
		javadoc <- javaDoc
	),
	
	BIT_Name: JavaAbstractSyntax!SimpleName(
		identifier<- 'BIT',
		fullyQualifiedName <- 'BIT'
	), 
	
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- BIT_Pack 
	),
	
	tester: JavaAbstractSyntax!TypeDeclaration(
		name <- nameTester,
		modifiers <- modMeth,
		--superclassType <- sType,
		javadoc <- javaD,
		bodyDeclarations <- Set{}
	),
	
	modMeth: JavaAbstractSyntax!Modifier(
	 	public <- true
	),
	
	nameTester:JavaAbstractSyntax!SimpleName(
		identifier<- t.name,
		fullyQualifiedName <- 'BIT.'+ t.name
	),
	
	javaD: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{javadoc},
		alternateRoot <- tester
	),
	 
	javadoc: JavaAbstractSyntax!TagElement(
		tagName <- nameTester.toString(),
		nested <- true,
		fragments <- Sequence{javadocText}
	),
	 
	javadocText: JavaAbstractSyntax!TextElement(
		text <- 'This code is automatically generated by the MoBIT Tool
		@author Everton Leandro'
	)
	
	do{
		self.createAttributeTester(tester);	
		self.createExecuteTest(pack, tester, cols);
		for (c in cols){
			for (i in c.ownedBehavior){
				self.createTestCase(pack, tester, i);
			}
		}
		
		pBIT.compilations <- pBIT.compilations->including(unit);
		
	}
}

rule createTestCase(pack: uml2!Package, class: JavaAbstractSyntax!TypeDeclaration, int: uml2!Interaction){
	using{
		msgs: uml2!MessageOccurrenceSpecification = int.getFragments();-->select(m | m.oclIsTypeOf(uml2!MessageOccurrenceSpecification));
	}
	to tCase: JavaAbstractSyntax!MethodDeclaration(
		name <- nameTestCase,
		body <- block,
		returnType <- voidType,
		javadoc <- javaDoc,
		modifiers <- modPUBTestCase,
		parameters <- Set{}
	),	
	
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- tCase 
	),
	
	voidType: JavaAbstractSyntax!PrimitiveType(
		code <- 'void'
	),
	
	block: JavaAbstractSyntax!Block(
		statements <- Set{try}
	),
	
	try :JavaAbstractSyntax!TryStatement(
		body <-  blockTestCase,
		catchClauses <- Sequence{catch, catch2},
		finally <- Bnull
	),
	
	Bnull: JavaAbstractSyntax!Block(
		
	),
	
	catch:JavaAbstractSyntax!CatchClause(
		exception<- exception,
		body <- arbiterInvocationSetVerdict
	),
	
	exception: JavaAbstractSyntax!SingleVariableDeclaration(
		name <- nameException,
		type <-exceptionType,
		initializer <- null2
	),
	
	null2: JavaAbstractSyntax!NullLiteral,
	
	nameException: JavaAbstractSyntax!SimpleName(
		identifier<-'e',
		fullyQualifiedName <- 'e'
	),
	
	exceptionType:  JavaAbstractSyntax!SimpleType(
		name <- exceptionTypeName
	),
	
	exceptionTypeName:JavaAbstractSyntax!SimpleName(
		identifier<-'Exception',
		fullyQualifiedName <- 'Exception'
	),
	
	arbiterInvocationSetVerdict: JavaAbstractSyntax!Block(
		statements <- arbiterInvocationSetVerdictExp
	),
	
	arbiterInvocationSetVerdictExp: JavaAbstractSyntax!ExpressionStatement(
		expression <- arbiterInvocationSetVerdictInvoc 
	),
	
	arbiterInvocationSetVerdictInvoc: JavaAbstractSyntax!MethodInvocation(
		expression <- nameArbiter,
		name <- setVerdictName,
		arguments <- Sequence{boolFalse, numOne}
	),
	
	nameArbiter: JavaAbstractSyntax!SimpleName(
		identifier<-'arbiter',
		fullyQualifiedName <- 'arbiter'
	),
	
	setVerdictName: JavaAbstractSyntax!SimpleName(
		identifier<- 'setVerdict',
		fullyQualifiedName <- 'setVerdict'
	),
	
	boolFalse: JavaAbstractSyntax!BooleanLiteral(
		booleanValue<- false
	),
	
	numOne: JavaAbstractSyntax!NumberLiteral(
		token <- '1'
	),
	
	catch2:JavaAbstractSyntax!CatchClause(
		exception<- error,
		body <- arbiterInvocationSetVerdict2
	),
	
	error: JavaAbstractSyntax!SingleVariableDeclaration(
		name <- nameError,
		type <-ErrorType,
		initializer <- null3
	),
	
	null3: JavaAbstractSyntax!NullLiteral,
	
	nameError: JavaAbstractSyntax!SimpleName(
		identifier<-'r',
		fullyQualifiedName <- 'r'
	),
	
	ErrorType:  JavaAbstractSyntax!SimpleType(
		name <- ErrorTypeName
	),
	
	ErrorTypeName:JavaAbstractSyntax!SimpleName(
		identifier<-'Error',
		fullyQualifiedName <- 'Error'
	),
	
	arbiterInvocationSetVerdict2: JavaAbstractSyntax!Block(
		statements <- arbiterInvocationSetVerdict2Exp
	),
	
	arbiterInvocationSetVerdict2Exp: JavaAbstractSyntax!ExpressionStatement(
		expression <- arbiterInvocationSetVerdict2Invoc
	),
	
	arbiterInvocationSetVerdict2Invoc: JavaAbstractSyntax!MethodInvocation(
		expression <- nameArbiter2,
		name <- setVerdictName2,
		arguments <- Sequence{boolFalse2, numTwo}
	),
	
	nameArbiter2: JavaAbstractSyntax!SimpleName(
		identifier<-'arbiter',
		fullyQualifiedName <- 'arbiter'
	),
	
	setVerdictName2: JavaAbstractSyntax!SimpleName(
		identifier<- 'setVerdict',
		fullyQualifiedName <- 'setVerdict'
	),
	
	boolFalse2: JavaAbstractSyntax!BooleanLiteral(
		booleanValue<- false
	),
	
	numTwo: JavaAbstractSyntax!NumberLiteral(
		token <- '2'
	),
	
	nameTestCase:JavaAbstractSyntax!SimpleName(
		identifier<-int.name,
		fullyQualifiedName <- int.name
	),
	
	modPUBTestCase: JavaAbstractSyntax!Modifier(
		public <- true
	),
	
	
	blockTestCase: JavaAbstractSyntax!Block(
		statements <- Sequence{}
	),
	
	arbdefinesPartialVeredictExp: JavaAbstractSyntax!ExpressionStatement(
		expression  <- arbdefinesPartialVeredict
	),
	
	arbdefinesPartialVeredict: JavaAbstractSyntax!MethodInvocation(
		expression <- nameArbiter3,
		name <- nameDefinesPartialVeredict
	),
	
	nameDefinesPartialVeredict: JavaAbstractSyntax!SimpleName(
		identifier<- 'definesPartialVeredict',
		fullyQualifiedName <- 'definesPartialVeredict'
	),
	
	nameArbiter3:JavaAbstractSyntax!SimpleName(
		identifier<-'arbiter',
		fullyQualifiedName <- 'arbiter'
	)
	
	do{
		--tCase.name.identifier.println();
		--msgs.toString().println();
		for (p in int.ownedParameter){
			if (p.name->size() > 0){
				self.inculdeParameterTC(p, tCase);
			}
		}
		
		for (m in msgs){
			if (m.oclIsTypeOf(uml2!CombinedFragment)){
				self.createInitialIF(blockTestCase, m);
				--'IF'.println();
			}else{
				if (m.oclIsTypeOf(uml2!MessageOccurrenceSpecification))
					--'NORMAL'.println();
					self.normalTC(blockTestCase, m);
			}
		}

		block.statements<- block.statements->including(arbdefinesPartialVeredictExp);
		class.bodyDeclarations <- class.bodyDeclarations->including(tCase);	
	}
}


rule inculdeParameterTC(p: uml2!Parameter, tCase: JavaAbstractSyntax!MethodDeclaration){
	to
	svd: JavaAbstractSyntax!SingleVariableDeclaration(
		name <- sn0,
		type <- st
	),
	
	st: JavaAbstractSyntax!SimpleType(
		name <- sn
	),
	
	sn0: JavaAbstractSyntax!SimpleName(
		identifier <- p.name
	),
	sn: JavaAbstractSyntax!SimpleName(
		identifier <- p.type.name
	)
	do{
		tCase.parameters <- tCase.parameters->including(svd);
	}
}

rule createInitialIF(blockTestCase: JavaAbstractSyntax!Block, cf:JavaAbstractSyntax!CombinedFragment){
	using{
		guard: String = cf.operand->first().guard.specification.value;
	}
	to
	ifS: JavaAbstractSyntax!IfStatement(
		expression <- exp,
		thenStatement <- block,
		elseStatement <- elseS
	),
	
	block: JavaAbstractSyntax!Block(
		statements <- Set{}
	),
	
	exp: JavaAbstractSyntax!SimpleName(
		identifier <- guard
	),
	
	elseS: JavaAbstractSyntax!Block(
		statements<- Set{es}
	),
	
	es: JavaAbstractSyntax!ExpressionStatement(
		expression <- mi
	),
	
	mi: JavaAbstractSyntax!MethodInvocation(
		expression <- snA,
		name <- name,
		arguments <- Set{}
	),
	
	snA: JavaAbstractSyntax!SimpleName(
		identifier <- 'arbiter'
	),
	
	name: JavaAbstractSyntax!SimpleName(
		identifier <- 'setVerdict'
	),
	
	bl: JavaAbstractSyntax!BooleanLiteral(
		booleanValue <- false
	),
	
	nl: JavaAbstractSyntax!NumberLiteral(
		token <- '1'
	)
	
	do{
		mi.arguments <- mi.arguments->including(bl)->including(nl);
		--cf.operand->first().guard.specification.value.toString().println();
		blockTestCase.statements <- blockTestCase.statements->including(ifS); 
		--'----------------'.println();
		--cf.operand->first().fragment.toString().println();
		for (m in cf.operand->first().fragment){
			self.normalTC(block, m);
		}
	}
}


rule normalTC(blockTestCase: JavaAbstractSyntax!Block, m: JavaAbstractSyntax!MessageOccurrenceSpecification){
	using {
		ev: uml2! CallEvent = m.event; 
	}
	do{
		--ev.toString().println();
		if ((not ev.oclIsUndefined()) and (not ev.operation.oclIsUndefined())){
			if (ev.operation.name->size()>4){
				--m.event.operation.name.println();
				if(ev.operation.name.substring(1,4)= 'isIn'){
					self.invocationSetVerdictInTestCase(blockTestCase,m.event.operation.name);
				}else{
					if (m.event.operation.name->size()>5){
				   		if (m.event.operation.name.substring(1,5)= 'setTo'){	
				   			self.invocationOperationInTestCase(blockTestCase,m.event);
				   		}else{
				   			self.invocationOperation(blockTestCase,m.event.operation);
				   		}
				   	}else{
				   		self.invocationOperation(blockTestCase,m.event.operation);	
				   	}
				}
			}else{
				self.invocationOperation(blockTestCase,m.event.operation);	
										
			}
			
		}
	}
}

rule invocationOperation (blockTestCase: JavaAbstractSyntax!Block, op: uml2!operation){
	to
	exp: JavaAbstractSyntax!ExpressionStatement(
		expression <- serverInvocation	
	),
	
	serverInvocation: JavaAbstractSyntax!MethodInvocation(
		expression <- nameServer,
		name <- opName,
		arguments <- Sequence{}
	),
	
	nameServer: JavaAbstractSyntax!SimpleName(
		identifier<-'server',
		fullyQualifiedName <- 'server'
	),
	
	opName: JavaAbstractSyntax!SimpleName(
		identifier<- op.name,
		fullyQualifiedName <- op.name
	)
	do{
		for (p in op.ownedParameter){
			--op.name.println();
			if (p.direction <> #out and p.direction <> #return){
				--p.name.toString().println();
				self.includeParameter(p, serverInvocation);
			}
		}
		blockTestCase.statements <- blockTestCase.statements->including(exp);
	}
}

rule includeParameter(p:uml2!Parameter, invocation: JavaAbstractSyntax!MethodInvocation){
	to 
	sn: JavaAbstractSyntax!SimpleName(
		identifier <- p.name
	)
	do{
	    invocation.arguments <- invocation.arguments->including(sn); 
	}
}

rule invocationSetVerdictInTestCase(blockTestCase: JavaAbstractSyntax!Block, op:String){
	to 
	exp: JavaAbstractSyntax!ExpressionStatement(
		expression <- arbiterInvocationSetVerdict	
	),
	
	arbiterInvocationSetVerdict: JavaAbstractSyntax!MethodInvocation(
		expression <- nameArbiter,
		name <- setVerdictName,
		arguments <- Sequence{serverInvocationOp, numZero}
	),
	
	nameArbiter: JavaAbstractSyntax!SimpleName(
		identifier<-'arbiter',
		fullyQualifiedName <- 'arbiter'
	),
	
	setVerdictName: JavaAbstractSyntax!SimpleName(
		identifier<- 'setVerdict',
		fullyQualifiedName <- 'setVerdict'
	),
	
	serverInvocationOp: JavaAbstractSyntax!MethodInvocation(
		expression <- nameServer,
		name <- opName
	),
	
	nameServer: JavaAbstractSyntax!SimpleName(
		identifier<-'server',
		fullyQualifiedName <- 'server'
	),
	
	opName: JavaAbstractSyntax!SimpleName(
		identifier<- op,
		fullyQualifiedName <- op
	),
	
	numZero: JavaAbstractSyntax!NumberLiteral(
		token <- '0'
	)
	
	do{
		blockTestCase.statements <- blockTestCase.statements->including(exp);
	}
}

rule invocationOperationInTestCase(blockTestCase: JavaAbstractSyntax!Block, ev:uml2!CallEvent){
	to 
	exp: JavaAbstractSyntax!ExpressionStatement(
		expression <- serverInvocationOp	
	),
	
	serverInvocationOp: JavaAbstractSyntax!MethodInvocation(
		expression <- nameServer,
		name <- opName,
		arguments <- Set{}
	),
	
	nameServer: JavaAbstractSyntax!SimpleName(
		identifier<-'server',
		fullyQualifiedName <- 'server'
	),
	
	opName: JavaAbstractSyntax!SimpleName(
		identifier<- ev.operation.name,
		fullyQualifiedName <- ev.operation.name
	)
	do{
		for (c in ev.getOwnedComments()){
			
			self.parameterString(serverInvocationOp, c);
		}
		blockTestCase.statements <- blockTestCase.statements->including(exp);
	}
}

rule parameterString(mi: JavaAbstractSyntax!MethodInvocation, cm: uml2!Comment){
	to
	sl: JavaAbstractSyntax!StringLiteral(
		escapedValue <- cm.body
	)
	do{
		mi.arguments <- mi.arguments->including(sl); 
	}
}

rule createAttributeTester(class: JavaAbstractSyntax!TypeDeclaration){
	using{
		testable: uml2!Class = thisModule.testable->first();
	} 
	to attribute1: JavaAbstractSyntax!FieldDeclaration(
		type <- typeServer,
		fragments <- Set{ at1Exp },
		javadoc <- javaDoc,
		modifiers<- visibylity
	),
	
	typeServer:  JavaAbstractSyntax!SimpleType(
		name <- TypeServerName
	),
	
	TypeServerName: JavaAbstractSyntax!SimpleName(
		identifier<- testable.name,
		fullyQualifiedName <- testable.name
	),
	
	visibylity: JavaAbstractSyntax!Modifier(
		private <- true
	),
	
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- attribute1 
	),
	
	at1Exp:JavaAbstractSyntax!VariableDeclarationFragment(
		name <- simpleNameAt1,
		initializer <- null
	),
		
	null: JavaAbstractSyntax!NullLiteral,
		
	simpleNameAt1: JavaAbstractSyntax!SimpleName(
		identifier<- 'server',
		fullyQualifiedName <- 'server'
	),
	
	attribute2: JavaAbstractSyntax!FieldDeclaration(
		type <- typeArbiter,
		fragments <- Set{ at2Exp },
		javadoc <- javaDoc2,
		modifiers<- visibylity
	),
	
	typeArbiter:  JavaAbstractSyntax!SimpleType(
		name <- TypeArbiterName
	),
	
	javaDoc2: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- attribute2 
	),
	
	TypeArbiterName: JavaAbstractSyntax!SimpleName(
		identifier<- thisModule.arbiter.name,
		fullyQualifiedName <- thisModule.arbiter.name
	),
		
	at2Exp:JavaAbstractSyntax!VariableDeclarationFragment(
		name <- simpleNameAt2,
		initializer <- null2
	),
		
	null2: JavaAbstractSyntax!NullLiteral,
		
	simpleNameAt2: JavaAbstractSyntax!SimpleName(
		identifier<- 'arbiter',
		fullyQualifiedName <- 'arbiter'
	)
	 
	do{
		 thisModule.arbiter.name.println();
--		thisModule.testable.toString().println();
		class.bodyDeclarations <- class.bodyDeclarations->including(attribute1)->including(attribute2);
	}
}

rule createExecuteTest(pack:uml2!Package, class: JavaAbstractSyntax!TypeDeclaration, cols: Sequence(uml2!Collaboration)){
	using{
		testable: UML2!Class = thisModule.testable->first();
	} 
	to 	methExecuteTest: JavaAbstractSyntax!MethodDeclaration(
		name <- nameExTest,
	 	body <- blockExTest,
		modifiers <- modExTest,
		javadoc <- javaDoc,
		returnType <- verType,
		parameters <- serverParameter
	),
	
	nameExTest: JavaAbstractSyntax!SimpleName(
		identifier<-'executeTest',
		fullyQualifiedName <- 'executeTest'
	),
	
	modExTest: JavaAbstractSyntax!Modifier(
	 	public <- true
	),
	
	javaDoc: JavaAbstractSyntax!Javadoc(
	 	tags <- Set{},
		alternateRoot <- methExecuteTest 
	),
	
	verType: JavaAbstractSyntax!SimpleType(
		name <- verTypeName
	),
	
	verTypeName: JavaAbstractSyntax!SimpleName(
		identifier<- thisModule.verdict.name.identifier,
		fullyQualifiedName <- thisModule.verdict.name.identifier
	), 
	
	blockExTest: JavaAbstractSyntax!Block(
		statements <- Sequence{}->including(inicArbExp)
		->including(inicParamServerExp)
	),
	
	returnExTest: JavaAbstractSyntax!ReturnStatement(
		expression<- arbGetVerdict
	),
	
	arbGetVerdict: JavaAbstractSyntax!MethodInvocation(
		expression <- nameVar2,
		name <- NameGetVerdict
	),
	
	nameVar2:JavaAbstractSyntax!SimpleName(
		identifier<-'arbiter',
		fullyQualifiedName <- 'arbiter'
	),
	
	NameGetVerdict: JavaAbstractSyntax!SimpleName(
		identifier<- 'getVerdict',
		fullyQualifiedName <- 'getVerdict'
	),
	
	serverParameter: JavaAbstractSyntax!SingleVariableDeclaration(
		name <- nameServer,
		type <- serverType,
		initializer <- null
	),
	
	null: JavaAbstractSyntax!NullLiteral,
	
	serverType:  JavaAbstractSyntax!SimpleType(
		name <- serverTypeName
	),
	
	serverTypeName: JavaAbstractSyntax!SimpleName(
		identifier<- testable.name,
		fullyQualifiedName <- testable.name
	),
	
	inicArbExp: JavaAbstractSyntax!ExpressionStatement(
		expression <- inicArb
	),
	
	inicArb: JavaAbstractSyntax!Assignment(
		leftHandSide <- nameArbiter,
		operator<- #ASSIGN,
		rightHandSide <- newArbiter
	),
	
	nameArbiter:JavaAbstractSyntax!SimpleName(
		identifier<-'arbiter',
		fullyQualifiedName <- 'arbiter'
	),
	
	newArbiter: JavaAbstractSyntax!ClassInstanceCreation(
		type <- arbType,
		expression <- null2,
		anonymousClassDeclaration <- nullAnony
	),
	
	null2: JavaAbstractSyntax!NullLiteral,
	
	nullAnony: JavaAbstractSyntax!AnonymousClassDeclaration,
	
	arbType:  JavaAbstractSyntax!SimpleType(
		name <- arbTypeName
	),
	
	arbTypeName: JavaAbstractSyntax!SimpleName(
		identifier<- thisModule.arbiter.name,
		fullyQualifiedName <- thisModule.arbiter.name
	),
	
	inicParamServerExp: JavaAbstractSyntax!ExpressionStatement(
		expression <- inicParamServer
	),	
	
	inicParamServer: JavaAbstractSyntax!Assignment(
		leftHandSide <- nameVar1,
		operator<- #ASSIGN,
		rightHandSide <- nameParameter
	),
	
	nameVar1:JavaAbstractSyntax!SimpleName(
		identifier<-'server',
		fullyQualifiedName <- 'server'
	),
	
	nameParameter: JavaAbstractSyntax!SimpleName(
		identifier<- 's',
		fullyQualifiedName <- 's'
	),
	
	nameServer: JavaAbstractSyntax!SimpleName(
		identifier<- 's',
		fullyQualifiedName <- 's'
	)
	do{	

		for (c in cols){
			for (i in c.ownedBehavior){
				for (p in i.ownedParameter){
					self.createVariableOfTestCase(blockExTest, p);	
				}
			}
			for (i in c.ownedBehavior){
				self.createInvocationOfTestCase(blockExTest, i);
			}
		}

		blockExTest.statements <- blockExTest.statements->including(returnExTest);
		class.bodyDeclarations <- class.bodyDeclarations->including(methExecuteTest);
	}
}

rule createVariableOfTestCase(block: JavaAbstractSyntax!Block, p: uml2!Paramenter ){
	to
	vds: JavaAbstractSyntax!VariableDeclarationStatement(
		type <- st,
		fragments <- vdf
	),
	
	st: JavaAbstractSyntax!SimpleType(
		name <- sn
	),
	
	sn: JavaAbstractSyntax!SimpleName(
		identifier <- p.type.name
	),
	
	vdf: JavaAbstractSyntax!VariableDeclarationFragment(
		name <- sn2,
		initializer <- sn3
	),
	
	sn2: JavaAbstractSyntax!SimpleName(
		identifier <- p.name
	),
	
	sn3: JavaAbstractSyntax!SimpleName(
		identifier <- ' '
	)
	do{
		p.name.println();
		block.statements <- block.statements->including(vds);
	}
	
}

rule createInvocationOfTestCase(block: JavaAbstractSyntax!Block, int: uml2!Interaction ){
	to TCExp: JavaAbstractSyntax! ExpressionStatement(
		expression <- TC
	),
	
	TC: JavaAbstractSyntax!MethodInvocation (
		name <- TCName,
		expression <- null,
		arguments <- Set{}
	),
	
	null: JavaAbstractSyntax!NullLiteral(
	
	),
	
	TCName: JavaAbstractSyntax!SimpleName (
		identifier<- int.name,
		fullyQualifiedName <- int.name
	)
	do{
		for (p in int.ownedParameter){
			self.includeParameterTCInvocation(p, TC);
		}
		block.statements <- block.statements->including(TCExp); 
	}
}

rule includeParameterTCInvocation(p: uml2!Parameter , tc: JavaAbstractSyntax!MethodInvocation ){
	to
	sn: JavaAbstractSyntax!SimpleName(
		identifier <- p.name
	)
	do{
		tc.arguments <- tc.arguments->including(sn);
	}
}
